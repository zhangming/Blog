(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{576:function(e,t,s){"use strict";s.r(t);var a=s(17),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("在介绍跨域之前我们先说说同源策略是什么")]),e._v(" "),s("h3",{attrs:{id:"同域策略是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同域策略是什么"}},[e._v("#")]),e._v(" 同域策略是什么")]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v('同源策略是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。\n  同源策略限制以下几种行为：')]),e._v(" "),s("ul",[s("li",[e._v("Cookie、LocalStorage 和 IndexDB 无法读取")]),e._v(" "),s("li",[e._v("DOM和JS对象无法获得")]),e._v(" "),s("li",[e._v("AJAX 请求不能发送")])]),e._v(" "),s("h3",{attrs:{id:"跨域是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跨域是什么"}},[e._v("#")]),e._v(" 跨域是什么")]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同（不在一个源）就是跨域，就会有跨域问题。")]),e._v(" "),s("h3",{attrs:{id:"常用的解决跨域的方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常用的解决跨域的方式"}},[e._v("#")]),e._v(" 常用的解决跨域的方式")]),e._v(" "),s("hr"),e._v(" "),s("h3",{attrs:{id:"_1-jsonp方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-jsonp方式"}},[e._v("#")]),e._v(" 1. jsonp方式")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("this.$http.jsonp('http://www.domian.com:8080/login',{\n   params:{},\n   jsonp:'onBack'\n}).then((res) =>{\n   console.log(res);\n})\n")])])]),s("ul",[s("li",[e._v("jsonp的缺点是只能实现get请求")])]),e._v(" "),s("h3",{attrs:{id:"_2-通过-postmessage-跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-通过-postmessage-跨域"}},[e._v("#")]),e._v(" 2. 通过 postMessage 跨域")]),e._v(" "),s("p",[e._v("postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多的可以进行跨域操作的 window 属性之一，它可用于解决以下方面的问题")]),e._v(" "),s("ul",[s("li",[e._v("页面和其打开的新窗口的数据传递")]),e._v(" "),s("li",[e._v("多窗口之间消息传递")]),e._v(" "),s("li",[e._v("页面与嵌套的iframe消息传递")]),e._v(" "),s("li",[e._v("上面三个场景的跨域数据传递")])]),e._v(" "),s("h3",{attrs:{id:"_3-跨域资源共享-cors"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-跨域资源共享-cors"}},[e._v("#")]),e._v(" 3. 跨域资源共享(CORS)")]),e._v(" "),s("p",[e._v('CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。\n它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。\nCORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。\n  浏览器将CORS跨域请求分为简单请求和非简单请求。\n  只要同时满足一下两个条件，就属于简单请求\n(1)使用下列方法之一：')]),e._v(" "),s("ul",[s("li",[e._v("head")]),e._v(" "),s("li",[e._v("get")]),e._v(" "),s("li",[e._v("post")])]),e._v(" "),s("p",[e._v("(2)请求的Heder是")]),e._v(" "),s("ul",[s("li",[e._v("Accept")]),e._v(" "),s("li",[e._v("Accept-Language")]),e._v(" "),s("li",[e._v("Content-Language")]),e._v(" "),s("li",[e._v("Content-Type: 只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain")])]),e._v(" "),s("p",[e._v("不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。")]),e._v(" "),s("h4",{attrs:{id:"简单请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简单请求"}},[e._v("#")]),e._v(" 简单请求")]),e._v(" "),s("p",[e._v("对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("GET /cors HTTP/1.1\n\nOrigin: http://api.bob.com\n\nHost: api.alice.com\n\nAccept-Language: en-US\n\nConnection: keep-alive\n\nUser-Agent: Mozilla/5.0...\n")])])]),s("p",[e._v("上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。")]),e._v(" "),s("h4",{attrs:{id:"cors请求设置的响应头字段-都以-access-control-开头"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cors请求设置的响应头字段-都以-access-control-开头"}},[e._v("#")]),e._v(" CORS请求设置的响应头字段，都以 Access-Control-开头:")]),e._v(" "),s("p",[e._v("1）Access-Control-Allow-Origin：必选\n  它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。")]),e._v(" "),s("p",[e._v("2）Access-Control-Allow-Credentials：可选\n  它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。")]),e._v(" "),s("p",[e._v("3）Access-Control-Expose-Headers：可选\n  CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。")]),e._v(" "),s("h4",{attrs:{id:"非简单请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非简单请求"}},[e._v("#")]),e._v(" 非简单请求")]),e._v(" "),s("p",[e._v('非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。')]),e._v(" "),s("h4",{attrs:{id:"预检请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#预检请求"}},[e._v("#")]),e._v(" 预检请求")]),e._v(" "),s("p",[e._v('预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，"预检"请求的头信息包括两个特殊字段。')]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("OPTIONS /cors HTTP/1.1\nOrigin: http://api.bob.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0..\n\n")])])]),s("p",[e._v("1）Access-Control-Request-Method：必选\n  用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。")]),e._v(" "),s("p",[e._v("2）Access-Control-Request-Headers：可选\n  该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。")]),e._v(" "),s("h4",{attrs:{id:"预检请求的回应"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#预检请求的回应"}},[e._v("#")]),e._v(" 预检请求的回应")]),e._v(" "),s("p",[e._v('服务器收到"预检"请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。\n  HTTP回应中，除了关键的是Access-Control-Allow-Origin字段，其他CORS相关字段如下：\n1）Access-Control-Allow-Methods：必选\n  它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。')]),e._v(" "),s("p",[e._v('2）Access-Control-Allow-Headers\n  如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。')]),e._v(" "),s("p",[e._v("3）Access-Control-Allow-Credentials：可选\n  该字段与简单请求时的含义相同。")]),e._v(" "),s("p",[e._v("4）Access-Control-Max-Age：可选\n  用来指定本次预检请求的有效期，单位为秒。")]),e._v(" "),s("p",[e._v("CORS跨域示例")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容\n\n// 前端设置是否带cookie\nxhr.withCredentials = true;\n\nxhr.open('post', 'http://www.domain2.com:8080/login', true);\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\nxhr.send('user=admin');\n\nxhr.onreadystatechange = function() {\n    if (xhr.readyState == 4 && xhr.status == 200) {\n        alert(xhr.responseText);\n    }\n};\n\n")])])]),s("h3",{attrs:{id:"_4-nginx-设置代理跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-nginx-设置代理跨域"}},[e._v("#")]),e._v(" 4. Nginx 设置代理跨域")]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin...等字段。")]),e._v(" "),s("h4",{attrs:{id:"_1-nginx-配置解决-iconfont-跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-nginx-配置解决-iconfont-跨域"}},[e._v("#")]),e._v(" 1)nginx 配置解决 iconfont 跨域")]),e._v(" "),s("p",[e._v("浏览器跨域访问 js、css、img 等常规静态资源被同源策略许可，但 iconfont 字体文件(eot|otf|ttf|woff|svg) 例外，此时可在 nginx 的静态资源服务器中加入以下配置。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("location / {\n  add_header Access-Control-Allow-Origin *;\n}\n\n")])])]),s("h4",{attrs:{id:"_2-nginx反向代理接口跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-nginx反向代理接口跨域"}},[e._v("#")]),e._v(" 2）nginx反向代理接口跨域")]),e._v(" "),s("p",[e._v("跨域原理：同源策略是浏览器的安全策略，不是 HTTP 协议的一部分。服务器端调用 HTTP 接口只是使用 HTTP 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨域问题。")]),e._v(" "),s("p",[e._v("实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中的 domain 信息，方便当前域 cookie 写入，实现跨域登录。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("#proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    }\n}\n\n")])])]),s("ol",{attrs:{start:"5"}},[s("li",[e._v("nodejs中间件代理跨域")]),e._v(" "),s("li",[e._v("document.domain + iframe跨域")]),e._v(" "),s("li",[e._v("location.hash + iframe跨域")]),e._v(" "),s("li",[e._v("window.name + iframe跨域")])]),e._v(" "),s("h2",{attrs:{id:"小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),s("p",[e._v("jsonp（只支持get请求，支持老的IE浏览器）适合加载不同域名的js、css，img等静态资源；CORS（支持所有类型的HTTP请求，但浏览器IE10以下不支持）适合做ajax各种跨域请求；Nginx代理跨域和nodejs中间件跨域原理都相似，都是搭建一个服务器，直接在服务器端请求HTTP接口，这适合前后端分离的前端项目调后端接口。document.domain+iframe适合主域名相同，子域名不同的跨域请求。postMessage、websocket都是HTML5新特性，兼容性不是很好，只适用于主流浏览器和IE10+。")])])}),[],!1,null,null,null);t.default=n.exports}}]);