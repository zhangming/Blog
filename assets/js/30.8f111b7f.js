(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{588:function(t,e,n){"use strict";n.r(e);var a=n(17),i=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"什么是-requestanimationframe"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是-requestanimationframe"}},[t._v("#")]),t._v(" 什么是 requestAnimationFrame")]),t._v(" "),n("ul",[n("li",[t._v("window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。 根据以上 MDN 的定义，requestAnimationFrame 是浏览器提供的一个按帧对网页进行重绘的 API 。先看下面这个例子，了解一下它是如何使用并运行的：")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const test = document.querySelector("#test");\nlet i = 0;\nfunction animation() {\n  if (i > 200) return;\n  test.style.marginLeft = `${i}px`;\n  window.requestAnimationFrame(animation);\n  i++;\n}\nwindow.requestAnimationFrame(animation);\n')])])]),n("p",[t._v("上面的代码 1s 大约执行 60 次，因为一般的屏幕硬件设备的刷新频率都是 60Hz，然后每执行一次大约是 16.7ms。使用 requestAnimationFrame 的时候，只需要反复调用它就可以实现动画效果。\n同时 requestAnimationFrame 会返回一个请求 ID，是回调函数列表中的一个唯一值，可以使用 cancelAnimationFrame 通过传入该请求 ID 取消回调函数。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const test = document.querySelector("#test");\nlet i = 0;\nlet requestId: number;\nfunction animation() {\n  test.style.marginLeft = `${i}px`;\n  requestId = requestAnimationFrame(animation);\n  i++;\n  if (i > 200) {\n    cancelAnimationFrame(requestId);\n  }\n}\nanimation();\n')])])]),n("h3",{attrs:{id:"requestanimationframe-执行的困惑"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#requestanimationframe-执行的困惑"}},[t._v("#")]),t._v(" requestAnimationFrame 执行的困惑")]),t._v(" "),n("p",[t._v("使用 JavaScript 实现动画的方式还可以使用 setTimeout ，在这里将 setTimeout 的执行间隔设置为 0，来模仿 requestAnimationFrame。下面是实现的代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const test = document.querySelector("#test")!;\nlet i = 0;\nlet timerId: number;\nfunction animation() {\n  test.style.marginLeft = `${i}px`;\n  // 执行间隔设置为 0，来模仿 requestAnimationFrame\n  timerId = setTimeout(animation, 0);\n  i++;\n  if (i > 200) {\n    clearTimeout(timerId);\n  }\n}\nanimation();\n')])])]),n("p",[t._v("单单从代码上实现的方式，看不出有什么区别，但是从具体的实现结果就可以看出很明显的差距了。\n很明显能看出，setTimeout 比 requestAnimationFrame 实现的动画“快”了很多。这是什么原因呢？\n可能你也猜到了，Event Loop 和 requestAnimationFrame 在执行的时候有些特殊的机制，下面就来探究一下 Event Loop 和 requestAnimationFrame 的关系。")]),t._v(" "),n("h3",{attrs:{id:"event-loop-与-requestanimationframe"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-与-requestanimationframe"}},[t._v("#")]),t._v(" Event Loop 与 requestAnimationFrame")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("requestAnimationFrame 的回调时机,它会在 style/layout/paint 之前调用。")])]),t._v(" "),n("li",[n("p",[t._v("首先，浏览器渲染有个渲染时机（Rendering opportunity）的问题，也就是浏览器会根据当前的浏览上下文判断是否进行渲染，它会尽量高效，只有必要的时候才进行渲染，如果没有界面的改变，就不会渲染。按照规范里说的一样，因为考虑到硬件的刷新频率限制、页面性能以及页面是否存在后台等等因素，有可能执行完 setTimeout 这个 task 之后，发现还没到渲染时机，所以 setTimeout 回调了几次之后才进行渲染，此时设置的 marginLeft 和上一次渲染前 marginLeft 的差值要大于 1px 的。")])]),t._v(" "),n("li",[n("p",[t._v("requestAnimationFrame 帧动画不同之处在于，每次渲染之前都会调用，此时设置的 marginLeft 和上一次渲染前 marginLeft 的差值为 1px 。")])]),t._v(" "),n("li",[n("p",[t._v("所以看上去 setTimeout “快”了很多。")])])])])}),[],!1,null,null,null);e.default=i.exports}}]);