(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{564:function(e,t,a){"use strict";a.r(t);var r=a(17),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("移动端web项目越来越多，设计师对于UI的要求也越来越高，比如1px 的边框。在高清屏下，移动端的1px 会很粗。\n比如，这个是假的1像素")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://i.bmp.ovh/imgs/2022/02/d558bf1daefd827b.png",alt:"image"}})]),e._v(" "),a("p",[e._v("这是真的1像素\n"),a("img",{attrs:{src:"https://i.bmp.ovh/imgs/2022/02/6008656fe80f0c90.png",alt:"image"}})]),e._v(" "),a("h3",{attrs:{id:"产生原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#产生原因"}},[e._v("#")]),e._v(" 产生原因")]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("那么为什么会产生这个问题呢？主要是跟一个东西有关，DPR(devicePixelRatio) 设备像素比，它是默认缩放为100%的情况下，设备像素和CSS像素的比值。")]),e._v(" "),a("p",[a("code",[e._v("window.devicePixelRatio=物理像素 /CSS像素")])]),e._v(" "),a("p",[e._v("目前主流的屏幕DPR=2 ,或者3。拿2倍屏来说，设备的物理像素要实现1像素，而DPR=2，所以css 像素只能是 0.5。一般设计稿是按照750来设计的，它上面的1px是以750来参照的，而我们写css样式是以设备375为参照的，所以我们应该写的0.5px就好了啊！ 试过了就知道，iOS 8+系统支持，安卓系统不支持。")]),e._v(" "),a("h3",{attrs:{id:"解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[e._v("#")]),e._v(" 解决方案")]),e._v(" "),a("hr"),e._v(" "),a("ol",[a("li",[e._v("WWDC对iOS统给出的方案\n在 WWDC大会上，给出来了1px方案，当写 0.5px的时候，就会显示一个物理像素宽度的 border，而不是一个css像素的 border。 所以在iOS下，你可以这样写。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("border:0.5px solid #E5E5E5\n")])])]),a("p",[e._v("总结：")]),e._v(" "),a("ul",[a("li",[e._v("优点：简单，没有副作用")]),e._v(" "),a("li",[e._v("缺点：支持iOS 8+，不支持安卓。后期安卓follow就好了。")])]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("使用边框图片")])]),e._v(" "),a("div",{staticClass:"language-border: 1px solid transparent; extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  border-image: url('./../../image/96.jpg') 2 repeat;\n")])])]),a("p",[e._v("这个方法在W3CPlus 上的例子讲的非常细致 "),a("a",{attrs:{href:"https://www.w3cplus.com/content/css3-border-image",target:"_blank",rel:"noopener noreferrer"}},[e._v("border-image"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("总结：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("优点：没有副作用")])]),e._v(" "),a("li",[a("p",[e._v("缺点：border颜色变了就得重新制作图片；圆角会比较模糊。")])])]),e._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[e._v("使用box-shadow实现\nbox-shadow用法可以看"),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-shadow",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),a("OutboundLink")],1)])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("    box-shadow: 0  -1px 1px -1px #e5e5e5,   //上边线\n            1px  0  1px -1px #e5e5e5,   //右边线\n            0  1px  1px -1px #e5e5e5,   //下边线\n            -1px 0  1px -1px #e5e5e5;   //左边线\n")])])]),a("p",[e._v("前面两个值 x，y 主要控制显示哪条边，后面两值控制的是阴影半径、扩展半径。 其实方法可以到"),a("a",{attrs:{href:"https://www.runoob.com/try/try.php?filename=trycss3_box-shadow",target:"_blank",rel:"noopener noreferrer"}},[e._v("这个地址"),a("OutboundLink")],1),e._v("线上尝试一下 。")]),e._v(" "),a("p",[e._v("总结")]),e._v(" "),a("p",[e._v("优点：使用简单，圆角也可以实现")]),e._v(" "),a("p",[e._v("缺点：模拟的实现方法，仔细看谁看不出来这是阴影不是边框。")]),e._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[e._v("使用伪元素\n这个方法是我比较推荐的，做出来的效果也是非常棒的，直接上代码。")])]),e._v(" "),a("ul",[a("li",[e._v("1条边框")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(".setOnePx{\n  position: relative;\n  &::after{\n    position: absolute;\n    content: '';\n    background-color: #e5e5e5;\n    display: block;\n    width: 100%;\n    height: 1px; /*no*/\n    transform: scale(1, 0.5);\n    top: 0;\n    left: 0;\n  }\n}\n\n")])])]),a("ul",[a("li",[e._v("4条边框")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('.setBorderAll{\n     position: relative;\n       &:after{\n           content:" ";\n           position:absolute;\n           top: 0;\n           left: 0;\n           width: 200%;\n           height: 200%;\n           transform: scale(0.5);\n           transform-origin: left top;\n           box-sizing: border-box;\n           border: 1px solid #E5E5E5;\n           border-radius: 4px;\n      }\n    }\n\n')])])]),a("p",[e._v("同样为伪元素设置绝对定位，并且和父元素左上角对其。将伪元素的长和宽先放大2倍，然后再设置一个边框，以左上角为中心，缩放到原来的0.5倍")]),e._v(" "),a("p",[e._v("总结：")]),e._v(" "),a("p",[e._v("优点：全机型兼容，实现了真正的1px，而且可以圆角。")]),e._v(" "),a("p",[e._v("缺点：暂用了after 伪元素，可能影响清除浮动。")])])}),[],!1,null,null,null);t.default=s.exports}}]);