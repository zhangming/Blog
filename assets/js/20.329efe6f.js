(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{571:function(n,t,a){"use strict";a.r(t);var e=a(17),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h3",{attrs:{id:"赋值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#赋值"}},[n._v("#")]),n._v(" 赋值")]),n._v(" "),a("ul",[a("li",[n._v("不会改变的值用 const")]),n._v(" "),a("li",[n._v("会改变的用 let（尽量不适用 var，let 是块级作用域，而 var 是函数级作用域）块级作用域 https://es6.ruanyifeng.com/#docs/let")]),n._v(" "),a("li",[n._v("不要使用八进制字面量，字符串字面量中也不要使用八进制转义字符")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("//bad\nconst a = 0123\nconst copyright = 'Copyright \\251'\n//good\nconst a = '0123'\n\n")])])]),a("h3",{attrs:{id:"variables"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#variables"}},[n._v("#")]),n._v(" variables")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("不要定义未使用的变量")])]),n._v(" "),a("li",[a("p",[n._v("每个变量都用一个 const 或 let，const 放在一起，let 放在一起")])]),n._v(" "),a("li",[a("p",[n._v("在你需要的地方声明变量，但是要放在合理的位置")])]),n._v(" "),a("li",[a("p",[n._v("不要使用链式声明变量(链式声明变量会创建隐式全局变量)")])]),n._v(" "),a("li",[a("p",[n._v("不要使用一元自增自减运算符")])]),n._v(" "),a("li",[a("p",[n._v("在赋值的时候避免在 = 前/后换行")])]),n._v(" "),a("li",[a("p",[n._v("不要对变量使用 delete 操作(https://juejin.cn/post/6844903918804172814)，采用设置成undefined的方式")])])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("//bad\nconst a = 0123\n//good\nconst a = '0123'\n\n/ bad - 不必要的函数调用。\nfunction checkName(hasName) {\n  const name = getName();\n\n  if (hasName === 'test') {\n    return false;\n  }\n\n  if (name === 'test') {\n    this.setName('');\n    return false;\n  }\n\n  return name;\n}\n\n// good\nfunction checkName(hasName) {\n  if (hasName === 'test') {\n    return false;\n  }\n\n  // 在需要的时候分配\n  const name = getName();\n\n  if (name === 'test') {\n    this.setName('');\n    return false;\n  }\n\n  return name;\n}\n\n// bad\n(function example() {\n  // JavaScript 将这一段解释为\n  // let a = ( b = ( c = 1 ) );\n  // let 只对变量 a 起作用; 变量 b 和 c 都变成了全局变量\n  let a = b = c = 1;\n}());\nconsole.log(a); // undefined\nconsole.log(b); // 1\nconsole.log(c); // 1\n\n// bad\nconst foo =\n  superLongLongLongLongLongLongLongLongFunctionName();\n// good\nconst foo = (\n  superLongLongLongLongLongLongLongLongFunctionName()\n);\n\n")])])]),a("h3",{attrs:{id:"解构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解构"}},[n._v("#")]),n._v(" 解构")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("用对象的解构赋值来获取和使用对象某个或多个属性值")])]),n._v(" "),a("li",[a("p",[n._v("用数组解构")])]),n._v(" "),a("li",[a("p",[n._v("多个返回值用对象的解构，而不是数组解构。")])]),n._v(" "),a("li",[a("p",[n._v("不要解构空值")])])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\n// bad\nfunction getFullName(user) {\n  const firstName = user.firstName;\n  const lastName = user.lastName;\n\n  return `${firstName} ${lastName}`;\n}\n\n// good\nfunction getFullName(user) {\n  const { firstName, lastName } = user;\n  return `${firstName} ${lastName}`;\n}\n\n// best\nfunction getFullName({ firstName, lastName }) {\n  return `${firstName} ${lastName}`;\n}\n\nconst arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr\n")])])]),a("h3",{attrs:{id:"对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[n._v("#")]),n._v(" 对象")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("使用字面量（{} 是字面量，可以立即求值，而 new Object() 本质上是方法（只不过这个方法是内置的）调用，既然是方法调用，就涉及到在 proto 链中遍历该方法，当找到该方法后，又会生产方法调用必须的堆栈信息，方法调用结束后，还要释放该堆栈）")])]),n._v(" "),a("li",[a("p",[n._v("用对象方法简写")])]),n._v(" "),a("li",[a("p",[n._v("用属性值缩写（将你的所有缩写放在对象声明的开始）")])]),n._v(" "),a("li",[a("p",[n._v("对象浅拷贝时，更推荐使用扩展运算符 ,获取对象属性时使用解构运算符")])]),n._v(" "),a("li",[a("p",[n._v("不要对全局只读对象重新赋值")])]),n._v(" "),a("li",[a("p",[n._v("外部变量不要与对象属性重名")])]),n._v(" "),a("li",[a("p",[n._v("禁止使用 Object 构造器，禁止使用 Symbol 构造器，禁止使用 Function 构造器，禁止使用原始包装器(String)")])]),n._v(" "),a("li",[a("p",[n._v("getPrototypeOf 来替代 "),a("strong",[n._v("proto")])])])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// bad\nconst atom = {\n  value: 1,\n\n  addValue: function (value) {\n    return atom.value + value;\n  },\n};\n\n// good\nconst atom = {\n  value: 1,\n\n  // 对象的方法\n  addValue(value) {\n    return atom.value + value;\n  },\n};\n\nconst lukeSkywalker = 'Luke Skywalker';\n\n// bad\nconst obj = {\n  lukeSkywalker: lukeSkywalker,\n};\n\n// good\nconst obj = {\n  lukeSkywalker,\n};\n// good es6 扩展运算符 ...\nconst original = { a: 1, b: 2 };\n// 浅拷贝\nconst copy = { ...original, c: 3 }; // copy => { a: 1, b: 2, c: 3 }\n\n// rest 解构运算符\nconst { a, ...noA } = copy; // noA => { b: 2, c: 3 }\n")])])]),a("h3",{attrs:{id:"array"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#array"}},[n._v("#")]),n._v(" Array")]),n._v(" "),a("p",[n._v("用字面量赋值")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("用扩展运算符做数组浅拷贝")])]),n._v(" "),a("li",[a("p",[n._v("用 ... 运算符而不是 Array.from 来将一个可迭代的对象转换成数组")])]),n._v(" "),a("li",[a("p",[n._v("如果一个数组有很多行，在数组的 [ 后和 ] 前断行")])]),n._v(" "),a("li",[a("p",[n._v("禁止使用稀疏数组")])])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("//bad\nvar nums = new Array(1, 2, 3)\n//good\nvar nums = [1, 2, 3]\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\nfor (i = 0; i < len; i += 1) {\n  itemsCopy[i] = items[i];\n}\n// good\nconst itemsCopy = [...items];\nconst arrLike = { 0: 'foo', 1: 'bar', 2: 'baz', length: 3 };\n// bad\nconst arr = Array.prototype.slice.call(arrLike);\n// good\nconst arr = Array.from(arrLike);\n")])])]),a("h3",{attrs:{id:"strings"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#strings"}},[n._v("#")]),n._v(" strings")]),n._v(" "),a("p",[n._v("用单引号")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("超过 100 个字符的字符串不应该用 string 串联成多行")])]),n._v(" "),a("li",[a("p",[n._v("用字符串模板而不是字符串拼接来组织可编程字符串")])]),n._v(" "),a("li",[a("p",[n._v("不使用 eval=>性能和安全性问题 https://www.zhihu.com/question/20591877")])])]),n._v(" "),a("h3",{attrs:{id:"null-undefined-的适用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#null-undefined-的适用场景"}},[n._v("#")]),n._v(" null&& undefined 的适用场景")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("不要使用 undefined 来初始化变量")])]),n._v(" "),a("li",[a("p",[n._v("避免空比较，对原始类型采用 typeof，对引用类型采用 instanceof，function 可以采用 typeof，属性采用 key in obj 判断，hasOwnProperty")])])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" //bad\nif (a == null) {\n //...\n}\n")])])]),a("h3",{attrs:{id:"函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[n._v("#")]),n._v(" 函数")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("用命名函数表达式而不是函数声明(在 ECMA-262 中 [块 block] 的定义是： 一系列的语句； 但是函数声明不是一个语句。 函数表达式是一个语句 http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html)")])]),n._v(" "),a("li",[a("p",[n._v("把立即执行函数包裹在圆括号里(可以令其函数中声明的变量绕过 JavaScript 的变量置顶声明规则，还可以避免新的变量被解释成全局变量或函数名占用全局变量名的情况。与此同时它能在禁止访问函数内声明变量的情况下允许外部对函数的调用)")])]),n._v(" "),a("li",[a("p",[n._v("不要用 arguments 命名参数，用 rest 语法...代替，避免使用 arguments.callee 和 arguments.caller")])]),n._v(" "),a("li",[a("p",[n._v("不要丢掉异常处理中 err 参数，catch 中不要对错误重新赋值")])]),n._v(" "),a("li",[a("p",[n._v("用默认参数语法而不是在函数里对参数重新赋值,不修改参数，把默认参数赋值放在最后(fixed)")])]),n._v(" "),a("li",[a("p",[n._v("函数签名部分要有空格，括号于函数名")])]),n._v(" "),a("li",[a("p",[n._v("调用或者书写一个包含多个参数的函数应该像其他多行代码写法一样： 每行只包含一个参数，每行逗号结尾")])]),n._v(" "),a("li",[a("p",[n._v("点号操作符须与属性需在同一行")])]),n._v(" "),a("li",[a("p",[n._v("函数调用时标识符与括号间不留间隔")])]),n._v(" "),a("li",[a("p",[n._v("对象中定义了存值器，一定要对应的定义取值器")])]),n._v(" "),a("li",[a("p",[n._v("使用 **dirname 和 **filename 时尽量避免使用字符串拼接(path.join)")])]),n._v(" "),a("li",[a("p",[n._v("return 语句中的赋值必需有括号包裹")])])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("    // bad\n    function foo() {\n      // ...\n    }\n\n// bad\n    const foo = function () {\n      // ...\n    };\n\n// good\n    // lexical name distinguished from the variable-referenced invocation(s)\n    // 函数表达式名和声明的函数名是不一样的\n    const short = function longUniqueMoreDescriptiveLexicalFoo() {\n      // ...\n    };\n// bad\nfunction concatenateAll () {\n  const args = Array.prototype.slice.call(arguments);\nreturn args.join('');\n}\n// good\nfunction concatenateAll(...args) {\n  return args.join('');\n}\n\n// good 缩进不要太过分\nfunction foo(\n  bar,\n  baz,\n  quux,\n) {\n  // ...\n}\n\na.request\n .then(...)\n\nfunction sum (a, b) {\n  return (result = a + b)   // ✓ ok\n}\n")])])]),a("h3",{attrs:{id:"箭头函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[n._v("#")]),n._v(" 箭头函数")]),n._v(" "),a("p",[n._v("用函数表达式（在回调函数里）的时候就用箭头表达式")]),n._v(" "),a("p",[n._v("如果函数体由一个没有副作用的表达式语句组成，删除大括号和 return。否则，继续用大括号和 return 语句")]),n._v(" "),a("p",[n._v("万一表达式涉及多行，把他包裹在圆括号里更可读")]),n._v(" "),a("p",[n._v("在隐式 return 中强制约束函数体的位置， 就写在箭头后面")]),n._v(" "),a("h3",{attrs:{id:"类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[n._v("#")]),n._v(" 类")]),n._v(" "),a("p",[n._v("不要扩展原生对象")]),n._v(" "),a("p",[n._v("常用 class，避免直接操作 prototype")]),n._v(" "),a("p",[n._v("构造函数以大写字母开头")]),n._v(" "),a("p",[n._v("子类的构造器中一定要调用 super")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\nObject.prototype.age = 123function Animal () {}var dog = new Animal()\n")])])]),a("h3",{attrs:{id:"modules"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#modules"}},[n._v("#")]),n._v(" Modules")]),n._v(" "),a("p",[n._v("不要直接从 import 中直接 export\n一个路径只 import 一次\n多行 import 应该缩进，就像多行数组和对象字面量\nIterators & Generators\n不要用遍历器。用 JavaScript 高级函数代替 for-in、 for-of\n不使用 generator 而使用 async await")]),n._v(" "),a("h3",{attrs:{id:"运算符-等号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运算符-等号"}},[n._v("#")]),n._v(" 运算符 & 等号")]),n._v(" "),a("p",[n._v("（https://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108）\n用 === 和 !== 而不是 == 和 !=")]),n._v(" "),a("p",[n._v("布尔值用缩写，而字符串和数字要明确比较对象")]),n._v(" "),a("p",[n._v("在 case 和 default 分句里用大括号创建一块包含语法声明的区域")]),n._v(" "),a("p",[n._v("三元表达式不应该嵌套，通常是单行表达式，避免不需要的三元表达式，对于三元运算符 ? 和 : 与他们所负责的代码处于同一行")]),n._v(" "),a("p",[n._v("关系运算符的左值不要做取反操作")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Object.prototype.age = 123\n\nconst a = false\nif(a) {\n}\n\n// good\nswitch (foo) {\n  case 1: {\n    let x = 1;\n    break;\n  }\n  case 2: {\n    const y = 2;\n    break;\n  }\n}\n\nif (!key in obj) {}\n")])])]),a("h3",{attrs:{id:"blocks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blocks"}},[n._v("#")]),n._v(" blocks")]),n._v(" "),a("p",[n._v("单行代码块两边加空格\nif 表达式的 else 和 if 的关闭大括号在一行\n嵌套的代码块中禁止再定义函数")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function foo () { return true }\n\nif (authenticated) {\n  function setAuthUser () {}    // ✗ avoid\n}\n")])])]),a("h3",{attrs:{id:"控制语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制语句"}},[n._v("#")]),n._v(" 控制语句")]),n._v(" "),a("p",[n._v("当你的控制语句(if, while 等)太长或者超过最大长度限制的时候， 把每一个(组)判断条件放在单独一行里。 逻辑操作符放在行首\n不要用选择操作符代替控制语句\n控制语句后面要用 {},多行 if 语句的括号， 使用左花括号放在行尾的对齐方式，else 关键字要与花括号保持在同一行")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// good\nif (\n  (foo === 123 || bar === 'abc')\n  && doesItLookGoodWhenItBecomesThatLong()\n  && isThisReallyHappening()\n) {\n  thing1();\n}\n\n// bad\n!isRunning && startRunning();\n\n")])])]),a("h3",{attrs:{id:"注释"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[n._v("#")]),n._v(" 注释")]),n._v(" "),a("p",[n._v("多行注释用/**/,单行注释用//,注释前后面空格")]),n._v(" "),a("ul",[a("li",[n._v("空格 ， 逗号，分号")]),n._v(" "),a("li",[n._v("不要混合使用空格与制表符作为缩进")]),n._v(" "),a("li",[n._v("行末不留空格")]),n._v(" "),a("li",[n._v("tab 用两个空格")]),n._v(" "),a("li",[n._v("关键字后面加空格")]),n._v(" "),a("li",[n._v("在大括号前空一格")]),n._v(" "),a("li",[n._v("在控制语句(if, while 等)的圆括号前空一格。在函数调用和定义时，参数列表和函数名之间不空格")]),n._v(" "),a("li",[n._v("用空格来隔开运算符")]),n._v(" "),a("li",[n._v("文件结尾空一行")]),n._v(" "),a("li",[n._v("当出现长的方法链（>2 个）时用缩进。用点开头强调该行是一个方法调用，而不是一个新的语句。")]),n._v(" "),a("li",[n._v("在一个代码块后下一条语句前空一行")]),n._v(" "),a("li",[n._v("不要用空白行填充块")]),n._v(" "),a("li",[n._v("圆括号里不要加空格，方括号里不要加空格，花括号里加空格(模板字符串中变量前后不加空格)")]),n._v(" "),a("li",[n._v("避免一行代码超过 100 个字符（包含空格）")]),n._v(" "),a("li",[n._v(", 前不要空格， , 后需要空格")]),n._v(" "),a("li",[n._v("在对象的字面量属性中， 冒号后空格")]),n._v(" "),a("li",[n._v("(额外结尾逗号),不允许有多余的行末逗号,始终将逗号置于行末")]),n._v(" "),a("li",[n._v("不要使用 (, [, or ` 等作为一行的开始.立即执行函数前加分号")]),n._v(" "),a("li",[n._v("遇到分号时空格要后留前不留")]),n._v(" "),a("li",[n._v("不允许有连续多行空行")]),n._v(" "),a("li",[n._v("文件末尾留一空行")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("for (let i = 0; i < items.length; i++) {...}\n")])])]),a("h3",{attrs:{id:"类型转换-强制类型转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型转换-强制类型转换"}},[n._v("#")]),n._v(" 类型转换 & 强制类型转换")]),n._v(" "),a("p",[n._v("parseInt 转换 string 常需要带上基数")]),n._v(" "),a("h3",{attrs:{id:"命名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名"}},[n._v("#")]),n._v(" 命名")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("用小驼峰式(keyValue)命名你的对象、函数、实例，用大驼峰式(KeyValue)命名类，【变量名义名词作为前缀，函数名用动词，尽量在变量名中体现出值的数据类型】")])]),n._v(" "),a("li",[a("p",[n._v("不要用前置或后置下划线")])]),n._v(" "),a("li",[a("p",[n._v("不要保存引用 this")])]),n._v(" "),a("li",[a("p",[n._v("export default 导出模块 A，则这个文件名也叫 A.*， import 时候的参数也叫 A。 大小写完全一致")])]),n._v(" "),a("li",[a("p",[n._v("当你 export-default 一个函数时，函数名用小驼峰，文件名需要和函数名一致")])]),n._v(" "),a("li",[a("p",[n._v("当你 export 一个结构体/类/单例/函数库/对象 时用大驼峰")])]),n._v(" "),a("li",[a("p",[n._v("简称和缩写应该全部大写或全部小写")])])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("for (let i = 0; i < items.length; i++) {...}\n function makeStyleGuide() { // ...\n}\nexport default makeStyleGuide;\nconst AirbnbStyleGuide = {es6: { }};\nexport default AirbnbStyleGuide;\nconst HTTPRequests = [ // ... ];\n")])])]),a("h3",{attrs:{id:"其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[n._v("#")]),n._v(" 其他")]),n._v(" "),a("ul",[a("li",[n._v("将配置数据抽离")]),n._v(" "),a("li",[n._v("单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。")]),n._v(" "),a("li",[n._v("应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V。")]),n._v(" "),a("li",[n._v("只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性")]),n._v(" "),a("li",[n._v("和父组件紧密耦合的子组件应该以父组件名作为前缀命名。(TodoList,TodolistItem,TodoListItemButton)")]),n._v(" "),a("li",[n._v("组件名应该倾向于完整单词而不是缩写。")]),n._v(" "),a("li",[n._v("在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。")]),n._v(" "),a("li",[n._v("组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法")]),n._v(" "),a("li",[n._v("应该把复杂计算属性分割为尽可能多的更简单的 property")]),n._v(" "),a("li",[n._v("组件的实例顺序：name，components,directives,filters,mixins,props,data,computed,watch,methods")]),n._v(" "),a("li",[n._v("如果一组 v-if + v-else 的元素类型相同，最好使用 key (比如两个<div> 元素)。")])]),n._v(" "),a("h3",{attrs:{id:"css"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[n._v("#")]),n._v(" css")]),n._v(" "),a("ul",[a("li",[n._v("将 css 从 javascript 中抽离")]),n._v(" "),a("li",[n._v("在类名称中优先使用破折号而不是驼峰（class）")]),n._v(" "),a("li",[n._v("不要使用 id 选择器")]),n._v(" "),a("li",[n._v("在规则声明中使用多个选择器时，每个选择器占据一行")]),n._v(" "),a("li",[n._v("在规则声明的左大括号{之前放置一个空格。")]),n._v(" "),a("li",[n._v("在属性中，在：字符之后（但不能在该字符之前）放置一个空格")]),n._v(" "),a("li",[n._v("将规则声明的右大括号}换行")]),n._v(" "),a("li",[n._v("在规则声明之间放置空白行")]),n._v(" "),a("li",[n._v("对于 border:使用 0 而不是 none 来指定样式没有边框")]),n._v(" "),a("li",[n._v("OOCSS 或“面向对象的 CSS”是一种写 CSS 的方法，它鼓励您将样式表视为“对象”的集合：可重复使用，可重复的代码段，可在整个网站中独立使用。")]),n._v(" "),a("li",[n._v("BEM“块元素修饰符”是 HTML 和 CSS 中类的命名约定")]),n._v(" "),a("li",[n._v("顺序：布局属性（display / position / float / clear / visibility / overflow）=>自身属性（width / height / margin / padding / border / background）=>文本属性（color / font / text-decoration / text-align / vertical-align / white- space / break-word）=>其他属性\nCSS3 浏览器私有前缀在前，标准前缀在后\nvue 样式\n为组件样式设置作用域（scoped 或 BEM 约定或 CSS Modules）\nvue dom\nv-for key 值\n在 dom 模板中 my-component，JS/JSX 中的组件名应该始终是 PascalCase 的\n元素 attribute 顺序：is, v-for，v-if (v-else-if v-show ),v-pre,v-once,id,ref,key,v-model,其他 attribute，v-on,v-html,v-text")])]),n._v(" "),a("p",[n._v("参考链接")]),n._v(" "),a("p",[n._v("https://github.com/lin-123/javascript")]),n._v(" "),a("p",[n._v("https://cn.vuejs.org/v2/style-guide/index.html")]),n._v(" "),a("p",[n._v("https://guide.aotu.io/docs/css/code.html")]),n._v(" "),a("p",[n._v("工具：")]),n._v(" "),a("p",[n._v("eslint")]),n._v(" "),a("p",[n._v("eslint-plugin-vue")])])}),[],!1,null,null,null);t.default=s.exports}}]);