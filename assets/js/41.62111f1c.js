(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{592:function(t,r,e){"use strict";e.r(r);var n=e(17),a=Object(n.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"js数组去重"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js数组去重"}},[t._v("#")]),t._v(" js数组去重")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("对以下所有的实现算法，都使用以下代码进行粗略测试：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const arr = [];\n// 生成[0, 100000]之间的随机数\nfor (let i = 0; i < 100000; i++) {\n  arr.push(0 + Math.floor((100000 - 0 + 1) * Math.random()))\n}\n\n// ...实现算法\n\nconsole.time('test');\narr.unique();\nconsole.timeEnd('test');\n\n")])])]),e("h3",{attrs:{id:"双重循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双重循环"}},[t._v("#")]),t._v(" 双重循环")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.prototype.unique = function () {\n  const newArray = [];\n  let isRepeat;\n  for (let i = 0; i < this.length; i++) {\n    isRepeat = false;\n    for (let j = i + 1; j < this.length; j++) {\n      if (this[i] === this[j]) {\n        isRepeat = true;\n        break;\n      }\n    }\n    if (!isRepeat) {\n      newArray.push(this[i]);\n    }\n  }\n  return newArray;\n}\n\n")])])]),e("h3",{attrs:{id:"array-prototype-indexof"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-indexof"}},[t._v("#")]),t._v(" Array.prototype.indexOf()")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("基本思路：如果索引不是第一个索引，说明是重复值。\n实现一：")]),t._v(" "),e("ul",[e("li",[t._v("利用Array.prototype.filter()过滤功能")]),t._v(" "),e("li",[t._v("Array.prototype.indexOf()返回的是第一个索引值")]),t._v(" "),e("li",[t._v("只将数组中元素第一次出现的返回")]),t._v(" "),e("li",[t._v("之后出现的将被过滤掉")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.prototype.unique = function () {\n  return this.filter((item, index) => {\n    return this.indexOf(item) === index;\n  })\n}\n\n")])])]),e("p",[t._v("实现二：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let arr = [1, 2, 3, 22, 233, 22, 2, 233, 'a', 3, 'b', 'a'];\nArray.prototype.unique = function () {\n  const newArray = [];\n  this.forEach(item => {\n    if (newArray.indexOf(item) === -1) {\n      newArray.push(item);\n    }\n  });\n  return newArray;\n}\n\n")])])]),e("h3",{attrs:{id:"array-prototype-sort"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-sort"}},[t._v("#")]),t._v(" Array.prototype.sort()")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("基本思路：先对原数组进行排序，然后再进行元素比较。\n实现一：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.prototype.unique = function () {\n  const newArray = [];\n  this.sort();\n  for (let i = 0; i < this.length; i++) {\n    if (this[i] !== this[i + 1]) {\n      newArray.push(this[i]);\n    }\n  }\n  return newArray;\n}\n\n")])])]),e("p",[t._v("实现二：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.prototype.unique = function () {\n  const newArray = [];\n  this.sort();\n  for (let i = 0; i < this.length; i++) {\n    if (this[i] !== newArray[newArray.length - 1]) {\n      newArray.push(this[i]);\n    }\n  }\n  return newArray;\n}\n\n")])])]),e("h3",{attrs:{id:"array-prototype-includes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-includes"}},[t._v("#")]),t._v(" Array.prototype.includes()")]),t._v(" "),e("hr"),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.prototype.unique = function () {\n  const newArray = [];\n  this.forEach(item => {\n    if (!newArray.includes(item)) {\n      newArray.push(item);\n    }\n  });\n  return newArray;\n}\n\n")])])]),e("h3",{attrs:{id:"array-prototype-reduce"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-reduce"}},[t._v("#")]),t._v(" Array.prototype.reduce()")]),t._v(" "),e("hr"),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.prototype.unique = function () {\n  return this.sort().reduce((init, current) => {\n    if(init.length === 0 || init[init.length - 1] !== current){\n      init.push(current);\n    }\n    return init;\n  }, []);\n}\n\n")])])]),e("h3",{attrs:{id:"map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[t._v("#")]),t._v(" Map")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("实现一：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.prototype.unique = function () {\n  const newArray = [];\n  const tmp = new Map();\n  for(let i = 0; i < this.length; i++){\n        if(!tmp.get(this[i])){\n            tmp.set(this[i], 1);\n            newArray.push(this[i]);\n        }\n    }\n    return newArray;\n}\n\n")])])]),e("p",[t._v("实现二：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.prototype.unique = function () {\n  const tmp = new Map();\n  return this.filter(item => {\n    return !tmp.has(item) && tmp.set(item, 1);\n  })\n}\n\n")])])]),e("h3",{attrs:{id:"set"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[t._v("#")]),t._v(" Set")]),t._v(" "),e("hr"),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.prototype.unique = function () {\n  const set = new Set(this);\n  return Array.from(set);\n}\n\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.prototype.unique = function () {\n  return [...new Set(this)];\n}\n\n")])])]),e("h3",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("除了考虑时间复杂度外、性能之外，还要考虑数组元素的数据类型（例如下面的例子）等问题权衡选择出采用哪种算法，例如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const arr = [1, 1, '1', '1', 0, 0, '0', '0', undefined, undefined, null, null, NaN, NaN, {}, {}, [], [], /a/, /a/];\n")])])]),e("p",[t._v("经过综合考虑，最优的数组去重算法是采用Map数据结构实现的算法。")])])}),[],!1,null,null,null);r.default=a.exports}}]);