(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{570:function(t,_,v){"use strict";v.r(_);var e=v(17),a=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"从输入url到页面加载发生了什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#从输入url到页面加载发生了什么"}},[t._v("#")]),t._v(" 从输入URL到页面加载发生了什么?")]),t._v(" "),v("p",[t._v("总体来说分为以下几个过程:")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("DNS解析")])]),t._v(" "),v("li",[v("p",[t._v("TCP连接")])]),t._v(" "),v("li",[v("p",[t._v("发送HTTP请求")])]),t._v(" "),v("li",[v("p",[t._v("服务器处理请求并返回HTTP报文")])]),t._v(" "),v("li",[v("p",[t._v("浏览器解析渲染页面")])]),t._v(" "),v("li",[v("p",[t._v("连接结束")])])]),t._v(" "),v("h3",{attrs:{id:"dns解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns解析"}},[t._v("#")]),t._v(" DNS解析")]),t._v(" "),v("hr"),t._v(" "),v("p",[t._v("DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换")]),t._v(" "),v("ul",[v("li",[t._v("解析过程图示")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://segmentfault.com/img/bVDM45?w=1928&h=1248",alt:"image"}})]),t._v(" "),v("ul",[v("li",[t._v("DNS优化：DNS缓存、DNS负载均衡")])]),t._v(" "),v("h3",{attrs:{id:"tcp连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp连接"}},[t._v("#")]),t._v(" TCP连接")]),t._v(" "),v("hr"),t._v(" "),v("p",[t._v("由于HTTP是一个无状态要求可靠传输的协议，所以我们需要建立TCP而不是UDP链接。")]),t._v(" "),v("p",[t._v("TCP在建立链接的时候,需要经过三次握手：")]),t._v(" "),v("p",[t._v("client先发送一个（SYN=1,seq=client_seq_num）标志的数据包给接收方")]),t._v(" "),v("p",[t._v("server接收后，回传一个（SYN=1,ack=client_seq+1,seq=server_seq_num）标志的数据包进行确认")]),t._v(" "),v("p",[t._v("client再回传一个（SYN=0,ack=server_seq+1）标志的数据包来表示握手成功")]),t._v(" "),v("blockquote",[v("p",[t._v("UDP 是一种无连接协议，而TCP 是一种面向连接的协议。 TCP 比UDP 要慢，这是两种协议的主要区别之一。 总的来说，UDP 是一种更快、更简单、更高效的协议。 但是只有TCP 允许对丢失的数据包进行重新传输。")])]),t._v(" "),v("h3",{attrs:{id:"http请求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http请求"}},[t._v("#")]),t._v(" HTTP请求")]),t._v(" "),v("hr"),t._v(" "),v("p",[t._v("发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。")]),t._v(" "),v("h4",{attrs:{id:"请求行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#请求行"}},[t._v("#")]),t._v(" 请求行")]),t._v(" "),v("p",[t._v("格式如下:\nMethod Request-URL HTTP-Version CRLF")]),t._v(" "),v("blockquote",[v("p",[t._v("eg: GET index.html HTTP/1.1")])]),t._v(" "),v("p",[t._v("常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。")]),t._v(" "),v("h5",{attrs:{id:"get-post的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#get-post的区别"}},[t._v("#")]),t._v(" GET/POST的区别")]),t._v(" "),v("ul",[v("li",[t._v("GET在浏览器回退时是无害的，而POST会再次提交请求。")]),t._v(" "),v("li",[t._v("GET产生的URL地址可以被Bookmark，而POST不可以。")]),t._v(" "),v("li",[t._v("GET请求会被浏览器主动cache，而POST不会，除非手动设置。")]),t._v(" "),v("li",[t._v("GET请求只能进行url编码，而POST支持多种编码方式。")]),t._v(" "),v("li",[t._v("GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。")]),t._v(" "),v("li",[t._v("GET请求在URL中传送的参数是有长度限制的，而POST没有。")]),t._v(" "),v("li",[t._v("对参数的数据类型，GET只接受ASCII字符，而POST没有限制。")]),t._v(" "),v("li",[t._v("GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。")]),t._v(" "),v("li",[t._v("GET参数通过URL传递，POST放在Request body中`")])]),t._v(" "),v("h4",{attrs:{id:"请求报头"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#请求报头"}},[t._v("#")]),t._v(" 请求报头")]),t._v(" "),v("p",[t._v("请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。")]),t._v(" "),v("p",[t._v("常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。")]),t._v(" "),v("h4",{attrs:{id:"请求正文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#请求正文"}},[t._v("#")]),t._v(" 请求正文")]),t._v(" "),v("p",[t._v("当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。")]),t._v(" "),v("h4",{attrs:{id:"状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#状态码"}},[t._v("#")]),t._v(" 状态码")]),t._v(" "),v("p",[t._v("状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:")]),t._v(" "),v("p",[t._v("1xx：指示信息–表示请求已接收，继续处理。")]),t._v(" "),v("p",[t._v("2xx：成功–表示请求已被成功接收、理解、接受。")]),t._v(" "),v("p",[t._v("3xx：重定向–要完成请求必须进行更进一步的操作。")]),t._v(" "),v("p",[t._v("4xx：客户端错误–请求有语法错误或请求无法实现。")]),t._v(" "),v("p",[t._v("5xx：服务器端错误–服务器未能实现合法的请求。\n平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500。")]),t._v(" "),v("blockquote",[v("p",[t._v("302重定向是暂时的重定向，搜索引擎会抓取新的内容而保存旧的网址。 由于效劳器前往302代码，搜索引擎以为新的网址只是暂时的。 301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://segmentfault.com/img/bVDNI1?w=2404&h=1342",alt:"image"}})]),t._v(" "),v("h3",{attrs:{id:"浏览器解析渲染页面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器解析渲染页面"}},[t._v("#")]),t._v(" 浏览器解析渲染页面")]),t._v(" "),v("hr"),t._v(" "),v("p",[v("img",{attrs:{src:"https://segmentfault.com/img/bVCZ1H?w=694&h=340",alt:"image"}})]),t._v(" "),v("p",[t._v("浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。")])])}),[],!1,null,null,null);_.default=a.exports}}]);