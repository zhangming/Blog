(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{587:function(a,t,e){"use strict";e.r(t);var s=e(17),i=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"webpack-进阶"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack-进阶"}},[a._v("#")]),a._v(" webpack 进阶")]),a._v(" "),e("h3",{attrs:{id:"自动清理构建目录产物"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自动清理构建目录产物"}},[a._v("#")]),a._v(" 自动清理构建目录产物")]),a._v(" "),e("ul",[e("li",[a._v("通过 npm scripts 清理构建目录 rm -rf ./dist && webpack 或者 rimraf ./dist && webpack")]),a._v(" "),e("li",[a._v("避免构建前每次都要手动删除 dist，使用 clean-webpack-plugin(默认会删除 output 指定的输出目录)")])]),a._v(" "),e("h3",{attrs:{id:"postcss-插件-autoprefixer-自动补齐-css3-前缀"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#postcss-插件-autoprefixer-自动补齐-css3-前缀"}},[a._v("#")]),a._v(" PostCSS 插件 autoprefixer 自动补齐 css3 前缀")]),a._v(" "),e("ul",[e("li",[a._v("具体配置如下：\n"),e("img",{attrs:{src:"https://s2.loli.net/2022/01/05/Je1MnxKur4hLQYw.png",alt:"image.png"}})])]),a._v(" "),e("h3",{attrs:{id:"移动端-css-px-自动转换成-rem"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#移动端-css-px-自动转换成-rem"}},[a._v("#")]),a._v(" 移动端 CSS PX 自动转换成 rem")]),a._v(" "),e("ul",[e("li",[a._v("移动端机型众多，分辨率不同，需要做适配")]),a._v(" "),e("li",[a._v("最早的适配，CSS 媒体查询实现响应式布局，缺陷：要写多套适配样式代码")]),a._v(" "),e("li",[a._v("css3 推出 rem 的适配单位，w3c 对 rem 定义：font-size of the root element")]),a._v(" "),e("li",[a._v("rem 和 px 的对比：rem 是相对单位，px 是绝对单位")]),a._v(" "),e("li",[a._v("使用 px2rem-loader 将 px 转换成 rem，页面渲染时计算根元素的 font-size 值")])]),a._v(" "),e("h3",{attrs:{id:"静态资源内联"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态资源内联"}},[a._v("#")]),a._v(" 静态资源内联")]),a._v(" "),e("ul",[e("li",[a._v("资源内联的意义：\n代码层面：页面框架初始化脚本，上报相关打点，css 内联避免页面闪动\n请求层面：减少 HTTP 网络请求（小图片或者字体内联 url-loader）")]),a._v(" "),e("li",[a._v("内联 html 和 js：raw-loader\n"),e("img",{attrs:{src:"https://s2.loli.net/2022/01/05/YrhUOTaAzk6XWl1.png",alt:"image.png"}})]),a._v(" "),e("li",[a._v("css 内联 ：style-loader 或 html-inline-css-webpack-plugin")])]),a._v(" "),e("h3",{attrs:{id:"多页面应用打包通用方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多页面应用打包通用方案"}},[a._v("#")]),a._v(" 多页面应用打包通用方案")]),a._v(" "),e("ul",[e("li",[a._v("多页面打包的基本思路：每个页面对应一个 entry,一个 html-webpack-plugin(缺点：每次新增或删除页面需要改 webpack 配置)")]),a._v(" "),e("li",[a._v("多页面打包通用方案：动态获取 entry 和设置 html-webpack-plugin 数量，利用 glob.sync\n"),e("code",[a._v("entry: glob.sync(path.join(__dirname,'./src/*/index.js'))")])])]),a._v(" "),e("h3",{attrs:{id:"使用-sourcemap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-sourcemap"}},[a._v("#")]),a._v(" 使用 sourcemap")]),a._v(" "),e("ul",[e("li",[a._v("作用：通过 source map 定位到源代码")]),a._v(" "),e("li",[a._v("开发环境开启，线上环境关闭（线上排查问题的时候可以将 sourcemap 上传到错误监控系统）")]),a._v(" "),e("li",[a._v("source map 关键字："),e("br"),a._v("\neval:使用 eval 包裹模块代码"),e("br"),a._v("\nsource map: 产生.map 文件"),e("br"),a._v("\ncheap: 不包含列信息"),e("br"),a._v("\ninline: 将.map 作为 DataURI 嵌入，不单独生成.map 文件"),e("br"),a._v("\nmodule:包含 loader 的 sourcemap")])]),a._v(" "),e("h3",{attrs:{id:"提取页面公共资源"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#提取页面公共资源"}},[a._v("#")]),a._v(" 提取页面公共资源")]),a._v(" "),e("ul",[e("li",[a._v("基础库分离：将 react、react-dom 基础库通过 cdn 引入，不打入 bundle 中")]),a._v(" "),e("li",[a._v("使用 html-webpack-externals-plugin")]),a._v(" "),e("li",[a._v("利用 SplitChunksPlugin 进行公共脚本分离（webpack4 内置的，替代 CommonsChunkPlugin 插件，chunks 参数说明：async 异步引入的库进行分离，initial 同步引入的库进行分离，all 所有引入的库进行分离）\n"),e("img",{attrs:{src:"https://s2.loli.net/2022/01/07/AYo1bcOj6zuVga8.png",alt:"image.png"}})])]),a._v(" "),e("h3",{attrs:{id:"tree-shaking-的使用和原理分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking-的使用和原理分析"}},[a._v("#")]),a._v(" Tree Shaking 的使用和原理分析")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("摇树优化，概念:1 个模块可能有多个⽅方法，只要其中的某个⽅方法使⽤用到了了，则整个⽂文件都会被打到 bundle ⾥里里⾯面去，tree shaking 就是只把⽤用到的⽅方法打⼊入 bundle ，没⽤用到的⽅方法会在 uglify 阶段被擦除掉")])]),a._v(" "),e("li",[e("p",[a._v("使用:webpack 默认⽀支持，在 .babelrc ⾥里里设置 modules: false 即可。 production mode 的情况下默认开启")])]),a._v(" "),e("li",[e("p",[a._v("要求:必须是 ES6 的语法，CJS 的⽅方式不不⽀支持")])]),a._v(" "),e("li",[e("p",[a._v("DCE（Elimination）代码不不会被执行，不可到达;代码执行的结果不会被用到;代码只会影响死变量(只写不不读)")])]),a._v(" "),e("li",[e("p",[a._v("Tree-shaking 原理：")]),a._v(" "),e("blockquote",[e("p",[a._v("利⽤ ES6 模块的特点:"),e("br"),a._v("\n只能作为模块顶层的语句句出现"),e("br"),a._v("\nimport 的模块名只能是字符串串常量量"),e("br"),a._v("\nimport binding 是 immutable 的"),e("br"),a._v("\n代码擦除: uglify 阶段删除⽆无⽤用代码")])])])]),a._v(" "),e("h3",{attrs:{id:"scope-hoisting-使用和原理分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#scope-hoisting-使用和原理分析"}},[a._v("#")]),a._v(" Scope Hoisting 使用和原理分析")]),a._v(" "),e("ul",[e("li",[a._v("现象:构建后的代码存在⼤量闭包代码，⼤量作用域包裹代码")]),a._v(" "),e("li",[a._v("导致:1.体积增⼤(模块越多越明显)；2.运行代码时创建的函数作用域变多，内存开销变⼤")]),a._v(" "),e("li",[a._v("scope hoisting 原理:将所有模块的代码按照引⽤用顺序放在⼀一个函数作⽤用域⾥里里，然后适当的重命名⼀一\n些变量量以防⽌止变量量名冲突")]),a._v(" "),e("li",[a._v("通过 scope hoisting 可以减少函数声明代码和内存开销\n"),e("blockquote",[e("p",[a._v("可以简单的把 scope hoisting 理解为是把每个模块被 webpack 处理成的模块初始化函数整理到一个统一的包裹函数里，也就是把多个作用域用一个作用域取代，以减少内存消耗并减少包裹块代码，从每个模块有一个包裹函数变成只有一个包裹函数包裹所有的模块，但是有一个前提就是，当模块的引用次数大于 1 时，比如被引用了两次或以上，那么这个效果会无效，也就是被引用多次的模块在被 webpack 处理后，会被独立的包裹函数所包裹")])])])]),a._v(" "),e("h3",{attrs:{id:"代码分割和动态-import"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码分割和动态-import"}},[a._v("#")]),a._v(" 代码分割和动态 import")]),a._v(" "),e("ul",[e("li",[a._v("代码分割的意义：对于⼤大的 Web 应⽤来讲，将所有的代码都放在一个文件中显然是不够有效的，特别是当你的 某些代码块是在某些特殊的时候才会被使用到。webpack 有⼀个功能就是将你的代码库分割成 chunks(语块)，当代码运⾏到需要它们的时候再进行加载")]),a._v(" "),e("li",[a._v("使用场景：1.抽离相同代码到⼀一个共享块；2.脚本懒加载，使得初始下载的代码更⼩")]),a._v(" "),e("li",[a._v("懒加载 JS 脚本的方式：1.CommonJS:require.ensure；2.ES6:动态 import(⽬目前还没有原⽣生⽀支持，需要 babel 转换")])]),a._v(" "),e("h3",{attrs:{id:"在-webpack-中使用-eslint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在-webpack-中使用-eslint"}},[a._v("#")]),a._v(" 在 webpack 中使用 ESLint")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("ESLint 代码检查工具")])]),a._v(" "),e("li",[e("p",[a._v("Airbnb: eslint-config-airbnb、eslint-config-airbnb-base")])]),a._v(" "),e("li",[e("p",[a._v("制定谈对的 ESLint 规范：1.不重复造轮子，基于 eslint:recommend 配置并改进；2.能够帮助发现代码错误的规则全部开启；3.帮助保持团队的代码风格统一，而不是限制开发体验。\n"),e("img",{attrs:{src:"https://s2.loli.net/2022/01/10/H8MQKfRBbO1Lu9z.png",alt:"image.png"}})])]),a._v(" "),e("li",[e("p",[a._v("ESLint 如何执行落地？")]),a._v(" "),e("ul",[e("li",[a._v("和 CI/CD 集成：安装 husky ,npm i husky --save-dev")]),a._v(" "),e("li",[a._v("和 webpack 集成: 使用 eslint-loader,构建时坚持啊 JS 规范")])])])]),a._v(" "),e("h3",{attrs:{id:"webpack-打包库和组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack-打包库和组件"}},[a._v("#")]),a._v(" webpack 打包库和组件")]),a._v(" "),e("ul",[e("li",[a._v("webpack 除了了可以⽤来打包应⽤，也可以用来打包 js 库")]),a._v(" "),e("li",[a._v("简单实现一个大整数加法库的打包：\n"),e("ul",[e("li",[a._v("1.需要打包压缩版和非压缩版；")]),a._v(" "),e("li",[a._v("2.支持 AMD/CJS/ESM 模块引入")])])])])])}),[],!1,null,null,null);t.default=i.exports}}]);