(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{584:function(n,r,a){"use strict";a.r(r);var e=a(17),t=Object(e.a)({},(function(){var n=this,r=n.$createElement,a=n._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("ul",[a("li",[n._v("浅拷贝和深拷贝都是对于JS中的引用类型而言的，浅拷贝就只是复制对象的引用，如果拷贝后的对象发生变化，原对象也会发生变化。只有深拷贝才是真正地对对象的拷贝。")])]),n._v(" "),a("h3",{attrs:{id:"浅拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝"}},[n._v("#")]),n._v(" 浅拷贝")]),n._v(" "),a("hr"),n._v(" "),a("ul",[a("li",[n._v("浅拷贝的意思就是只复制引用，而未复制真正的值.")])]),n._v(" "),a("div",{staticClass:"language-md extra-class"},[a("pre",{pre:!0,attrs:{class:"language-md"}},[a("code",[n._v("const originArray = [1,2,3,4,5];\nconst originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\n\nconst cloneArray = originArray;\nconst cloneObj = originObj;\n\nconsole.log(cloneArray); // [1,2,3,4,5]\nconsole.log(originObj); // {a:'a',b:'b',c:Array[3],d:{dd:'dd'}}\n\ncloneArray.push(6);\ncloneObj.a = {aa:'aa'};\n\nconsole.log(cloneArray); // [1,2,3,4,5,6]\nconsole.log(originArray); // [1,2,3,4,5,6]\n\nconsole.log(cloneObj); // {a:{aa:'aa'},b:'b',c:Array[3],d:{dd:'dd'}}\nconsole.log(originArray); // {a:{aa:'aa'},b:'b',c:Array[3],d:{dd:'dd'}}\n")])])]),a("ul",[a("li",[a("p",[n._v("上面的代码是最简单的利用 = 赋值操作符实现了一个浅拷贝，可以很清楚的看到，随着 cloneArray 和 cloneObj 改变，originArray 和 originObj 也随着发生了变化")])]),n._v(" "),a("li",[a("p",[n._v("浅拷贝的简单实现")])])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function shallowClone(source) {\n   var target = {};\n   for(var i in source) {\n       if (source.hasOwnProperty(i)) {\n           target[i] = source[i];\n       }\n   }\n\n   return target;\n}\n\n")])])]),a("h3",{attrs:{id:"深拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝"}},[n._v("#")]),n._v(" 深拷贝")]),n._v(" "),a("hr"),n._v(" "),a("ul",[a("li",[a("p",[n._v("深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。")])]),n._v(" "),a("li",[a("p",[n._v("目前实现深拷贝的方法不多，主要是两种：")]),n._v(" "),a("ul",[a("li",[n._v("利用 JSON 对象中的 parse 和 stringify")]),n._v(" "),a("li",[n._v("利用递归来实现每一层都重新创建对象并赋值")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 只有一层的简单数据结构 \nfunction cloneJSON(source) {\n    return JSON.parse(JSON.stringify(source));\n}\n\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 最简单的深拷贝\n\nfunction clone(source) {\n    var target = {};\n    for(var i in source) {\n        if (source.hasOwnProperty(i)) {\n            if (typeof source[i] === 'object') {\n                target[i] = clone(source[i]); // 注意这里\n            } else {\n                target[i] = source[i];\n            }\n        }\n    }\n\n    return target;\n}\n\n")])])])])]),n._v(" "),a("p",[n._v("其实上面的代码问题太多了，先来举几个例子吧")]),n._v(" "),a("ul",[a("li",[n._v("没有对参数做检验")]),n._v(" "),a("li",[n._v("判断是否对象的逻辑不够严谨")]),n._v(" "),a("li",[n._v("没有考虑数组的兼容")])]),n._v(" "),a("p",[n._v("完美的办法可以"),a("a",{attrs:{href:"https://github.com/jsmini/type/blob/master/src/index.js",target:"_blank",rel:"noopener noreferrer"}},[n._v("看看这里"),a("OutboundLink")],1)]),n._v(" "),a("p",[n._v("(其实完美办法也只能实现有限制条件的“深”拷贝，目前笔者还没有找到真正的‘完美’方法)")])])}),[],!1,null,null,null);r.default=t.exports}}]);